やること
-------
bonus作る

提出前確認、あのチェックシート使ってやるか！
＝＝＝＝＝＝＝＝
シグナル確認bonus　
->今あるファイルに実装しちゃって
内容全く同じのボーナスファイルを複製して作って、makefileにルールを追加する
signal送った後にポーズかけるか
もういいや、出しちまおう

makefileどうすっかな
makeすると二個つくるように
作った　チェックしよう

atoiのアルファベットはじくやつ
0009とか弾く
0009adfsとかのことね！
エラーケース関数作ってatoiで弾く

ワカモレでやるとバグンないじゃんw　人に聞くの大事

shigecord

一文字ごとでも良さそ

client 9行目
−１で試せば対策できるかためせる

kill -1 0を切った方がいい

ヌルを最後に遅ればわかりやすい

一回見直そう全てを
pdfみて、他人の実装見て判断

楽しむんやで

普通にバグってるのでボーナス対応とstrlen方式の実装
limits.hかunistd.hに限界量描かれてるのでチェック
sizetならいいだろ

The server confirms every signal received by sending a signal to the client.

超長いのを送る途中でダウンとか、ディフェンス

signal、killの仕様復習する

best practice
kill sigactionとか同時にwriteを呼び出すとゴミ

----------

１００strlen１秒以内

string貯めなきゃいけないじゃんw　めんどくさ
→まずstrlenをサーバーに報告してアロケートしてもらう
→そして、受け入れ先に順次収容
->放置

gloval variableは構造体で良さそうだ

たまにバグる原因を解明する
なんでバグんや
serverがわなきはしている
siaction見直す
エラー処る
人に聞く

pdf見直す

clean explained codec
https://github.com/mlanca-c/Minitalk/blob/main/client.c

makefileを作ろう　あとで

.hつくた

勉強すること：
pdf読んで仕様確認
bit演算
sigaction

mini_talkだいたいできてる気がする　誰かの話を聞く

つまり、stringを構成している文字を、それぞれ八個のシグナルを送ることで表現　０＝sigusr1 1=sigusr2
１００文字なら八百回送って、
それを文字に直せばいいのか

sigkillで送るやつやるかー

12/26

sigactioniで遊ぶかw

killで最初に
kill0 pid 0か１送る